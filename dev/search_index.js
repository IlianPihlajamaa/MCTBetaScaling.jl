var documenterSearchIndex = {"docs":
[{"location":"#Beta-scaling-equation","page":"Home","title":"Beta-scaling equation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The beta-scaling model is implemented to make it easier to find critical exponents of MCT. The equation is","category":"page"},{"location":"","page":"Home","title":"Home","text":"sigma - delta t + lambda (g(t))^2 = partial_tg(t-tau)g(tau)dtau","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, sigma is the distance from the critical point, lambda is the relevant eigenvalue of the stability matrix. g(t) describes the deviation of the order parameter from the plateau. delta is an optional hopping parameter, defaulting to 0 if not specified. Each of the parameters have to be floating point numbers.  ","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In order to solve the beta-scaling equation, we have to specify the parameters defining the equation and a time-scale t0 that shifts the results. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ModeCouplingTheory\nusing MCTBetaScaling, Plots\nλ = 0.7; ϵ = -0.1; t0 = 0.001\nequation = BetaScalingEquation(λ, ϵ, t0)\nsol = solve(equation, TimeDoublingSolver(t_max=10^4.))\nplot(log10.(sol.t), log10.(abs.(sol.F)), ylabel=\"log_{10}(|g(t)|)\", xlabel=\"log_{10}(t)\", label=\"g(t)\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: image)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the figure, the slopes of the straight lines are given by the parameters -a and b, which describe the relaxation towards and away from the plateau value of the correlator. These exponents are automatically computed, and are stored in equation.coeff.a and equation.coeff.b.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Götze, J Phys Condens Matter 2, 8485 (1990)","category":"page"},{"location":"#Stochastic-Beta-Relaxation-(SBR)","page":"Home","title":"Stochastic Beta-Relaxation (SBR)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SBR is an extension of the beta-scaling equation, where the parameter sigma becomes quenched disorder, and a diffusive term is added sigma(x) + alpha nabla^2 g(xt) - delta t + lambda (g(xt))^2 = partial_t int g(xt-tau)g(xtau)dtau","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is implemented in 1, 2, and 3 dimensions with periodic boundaries. Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ModeCouplingTheory, MCTBetaScaling, Plots, Random\nL_sys = 100.0 ## physical size of the system\nn = 100 ## number of sites on one side of the lattice\ndims = 2 \nLs = ntuple(i -> L_sys,  dims)  # Lattice size in each dimension\nns = ntuple(i -> n, dims)  # Number of sites in one dimension of the lattice\nRandom.seed!(52342)\nλ = 0.75\nα = 0.1\nt₀ = 0.001\nσ0 = 0.05 # target σ\ndelta_σ2 = 0.1  # desired variance\ndx = L_sys/n\n\n# small random variations near σ = 0. We divide by dx^2 to get the proper discretization\nσ_vec = [σ0 + delta_σ2/dx^2*randn() for i in 1:prod(ns)]  \n\neqn_sys = MCTBetaScaling.StochasticBetaScalingEquation(λ, α, σ_vec, t₀, Ls, ns)\nsolver = TimeDoublingSolver(t_max=10^10., verbose=true, tolerance=1e-10, N=16, Δt=1e-5)\nsol = solve(eqn_sys, solver)\n\np = plot(xlabel=\"t\", xscale=:log10, yscale=:log10, ylabel=\"g(x,t)\", xlims=(10^-5, 10^10), ylims=(10^-3, 10^2))\nfor i in 1:100:length(σ_vec) # plot 100 out of the 10000 curves\n    plot!(p, sol.t[2:end], get_F(sol, 2:length(sol.t), i), label=nothing)\nend\ndisplay(p)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: image)","category":"page"},{"location":"API/#Module-Index","page":"API","title":"Module Index","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [MCTBetaScaling]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"API/#Detailed-API","page":"API","title":"Detailed API","text":"","category":"section"},{"location":"API/#MCTBetaScaling.BetaScalingEquation-Tuple{Float64, Float64, Float64}","page":"API","title":"MCTBetaScaling.BetaScalingEquation","text":"BetaScalingEquation(λ, σ, t₀, δ=0.0)\n\nDefines the β-scaling equation of MCT, which is a scalar equation for a single scaling function g(t), determined by scalar parameters λ (the MCT exponent parameter, 1/2<=λ<1), the distance parameter to the glass transition σ, and (for convenience) an arbitrary time scale t₀ that just shifts the results. Optionally, a \"hopping parameter\" δ can be given (defaults to zero).\n\nThe MCT exponents a and b will be automatically calculated from λ.\n\n\n\n\n\n","category":"method"},{"location":"API/#MCTBetaScaling.StochasticBetaScalingEquation-Tuple{Float64, Float64, Vector{Float64}, Float64, Float64, Int64}","page":"API","title":"MCTBetaScaling.StochasticBetaScalingEquation","text":"StochasticBetaScalingEquation(λ::Float64, α::Float64, σ::Vector{Float64}, t₀::Float64, L_sys::Float64, ns::Int; δ=zeros(length(σ)))\n\nCreates a stochastic β-scaling equation object for a system with specified parameters. This is a convenience constructor 1D systems.\n\n\n\n\n\n","category":"method"},{"location":"API/#MCTBetaScaling.StochasticBetaScalingEquation-Union{Tuple{DIMS}, Tuple{Float64, Float64, Vector{Float64}, Float64, NTuple{DIMS, Float64}, NTuple{DIMS, Int64}}} where DIMS","page":"API","title":"MCTBetaScaling.StochasticBetaScalingEquation","text":"StochasticBetaScalingEquation(λ::Float64, α::Float64, σ::Vector{Float64}, t₀::Float64, L_sys::NTuple{DIMS, Float64}, ns::NTuple{DIMS, Int}; δ=zeros(length(σ))) where DIMS\n\nCreates a stochastic β-scaling equation object for a system with specified parameters. This equation is defined as:\n\nσ(x) - δ t + λ (g(x,t))² + α ∇²g(x,t) = ∂ₜ∫g(x, t-τ)g(x, τ)dτ\n\nwhere σ is a vector of site-dependent noise, δ is a vector of damping coefficients, λ is the coupling constant, α is the diffusion coefficient, t₀ is a reference time, and L_sys is the system size in each dimension.\n\n\n\n\n\n","category":"method"},{"location":"API/#MCTBetaScaling.regula_falsi-Tuple{Any, Any, Any}","page":"API","title":"MCTBetaScaling.regula_falsi","text":"regula_falsi(x0::Float64, x1::Float64, f; accuracy=10^-10, max_iterations=10^4)\n\nImplements a simple \"regular falsi\" search to find a point x where f(x)=0 within the given accuracy, starting in the interval [x0,x1]. For purists, f(x) should have exactly one root in the given interval, and the scheme will then converge to that. The present code is a bit more robust, at the expense of not guaranteeing convergence strictly.\n\nReturns a point x such that approximately f(x)==0 (unless the maximum number of iterations has been exceeded). If exactly one of the roots of f(x) lie in the initially given interval [x0,x1], the returned x will be the approximation to that root.\n\nArguments:\n\nx0: lower bound of the initial search interval\nx1: upper bound of the initial search interval\nf: a function accepting one real value, return one real value\n\n\n\n\n\n","category":"method"},{"location":"API/#ModeCouplingTheory.do_time_steps!-Tuple{Union{BetaScalingEquation, StochasticBetaScalingEquation}, ModeCouplingTheory.TimeDoublingSolver, Any, ModeCouplingTheory.AbstractSolverCache}","page":"API","title":"ModeCouplingTheory.do_time_steps!","text":"do_time_steps!(equation::MemoryEquation, solver::TimeDoublingSolver, kernel::MemoryKernel, temp_arrays::SolverCache)\n\nSolves the equation on the time points with index 2N+1 until 4N, for each point doing a recursive iteration to find the solution to the nonlinear equation C1 F  = -C2 M(F) + C3.\n\n\n\n\n\n","category":"method"},{"location":"API/#ModeCouplingTheory.initialize_F_temp!-Tuple{BetaScalingEquation, ModeCouplingTheory.TimeDoublingSolver, ModeCouplingTheory.SolverCache}","page":"API","title":"ModeCouplingTheory.initialize_F_temp!","text":"initialize_F_temp!(equation::BetaScalingEquation, solver::ModeCouplingTheory.TimeDoublingSolver, temp_arrays::ModeCouplingTheory.SolverCache)\n\nFills the first 2N entries of the temporary arrays needed for solving the β-scaling equation with a an adapted Fuchs scheme.\n\nIn particular, this initializes g(t) = (t/t₀)^-a.\n\n\n\n\n\n","category":"method"},{"location":"API/#ModeCouplingTheory.initialize_F_temp!-Tuple{StochasticBetaScalingEquation, ModeCouplingTheory.TimeDoublingSolver, ModeCouplingTheory.SolverCache}","page":"API","title":"ModeCouplingTheory.initialize_F_temp!","text":"initialize_F_temp!(equation::BetaScalingEquation, solver::ModeCouplingTheory.TimeDoublingSolver, temp_arrays::ModeCouplingTheory.SolverCache)\n\nFills the first 2N entries of the temporary arrays needed for solving the β-scaling equation with a an adapted Fuchs scheme.\n\nIn particular, this initializes g(t) = (t/t₀)^-a + A1 * σ(x) * (t/t0)^(a)\n\n\n\n\n\n","category":"method"},{"location":"API/#ModeCouplingTheory.initialize_integrals!-Tuple{BetaScalingEquation, ModeCouplingTheory.TimeDoublingSolver, ModeCouplingTheory.SolverCache}","page":"API","title":"ModeCouplingTheory.initialize_integrals!","text":"initialize_integrals!(equation::BetaScalingEquation, solver::ModeCouplingTheory.TimeDoublingSolver, temp_arrays::ModeCouplingTheory.SolverCache)\n\nInitializes the integrals over the first 2N time points for the solution of the β-scaling equation, using the known critical decay law as the short-time asymptote.\n\n\n\n\n\n","category":"method"},{"location":"API/#ModeCouplingTheory.initialize_integrals!-Tuple{StochasticBetaScalingEquation, ModeCouplingTheory.TimeDoublingSolver, ModeCouplingTheory.SolverCache}","page":"API","title":"ModeCouplingTheory.initialize_integrals!","text":"initialize_integrals!(equation::BetaScalingEquation, solver::ModeCouplingTheory.TimeDoublingSolver, temp_arrays::ModeCouplingTheory.SolverCache)\n\nInitializes the integrals over the first 2N time points for the solution of the β-scaling equation, using the known critical decay law as the short-time asymptote.\n\n\n\n\n\n","category":"method"},{"location":"API/#ModeCouplingTheory.update_Fuchs_parameters!-Tuple{BetaScalingEquation, ModeCouplingTheory.TimeDoublingSolver, ModeCouplingTheory.SolverCache, Int64}","page":"API","title":"ModeCouplingTheory.update_Fuchs_parameters!","text":"update_Fuchs_parameters!(equation::BetaScalingEquation, solver::ModeCouplingTheory.TimeDoublingSolver, temp_arrays::ModeCouplingTheory.SolverCache, it::Int)\n\nUpdates the parameters that are needed to solve the β-scaling equation numerically with Fuchs' scheme.\n\n\n\n\n\n","category":"method"},{"location":"API/#ModeCouplingTheory.update_Fuchs_parameters!-Tuple{StochasticBetaScalingEquation, ModeCouplingTheory.TimeDoublingSolver, ModeCouplingTheory.SolverCache, Int64}","page":"API","title":"ModeCouplingTheory.update_Fuchs_parameters!","text":"update_Fuchs_parameters!(equation::BetaScalingEquation, solver::ModeCouplingTheory.TimeDoublingSolver, temp_arrays::ModeCouplingTheory.SolverCache, it::Int)\n\nUpdates the parameters that are needed to solve the β-scaling equation numerically with Fuchs' scheme.\n\n\n\n\n\n","category":"method"}]
}
